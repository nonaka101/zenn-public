---
title: "📄設計：コントローラーについて"
---

## はじめに

本項では、コントローラー（Wii ヌンチャク）の物理的な機能と通信方法について説明していきます。

## 物理的な機能

![ヌンチャクコントローラー](/images/books/nunchuk-mouse/nunchuck_data-00.png =320x)

コントローラーには、下記の機能が搭載されています。本段落では、それぞれを詳しく見ていきます。

- スティック
- ボタン ✕ ２
- 加速度センサー

### スティック

![コントローラーのスティック部に焦点](/images/books/nunchuk-mouse/nunchuck_data-01.png =320x)

スティック部では、その傾き度合いを 2 軸の数値情報 `(x, y)` で表現することができます。

仮に原点を `(0, 0)` とし、計測できる範囲を 各軸 `± 10` とした場合、例えば下記のようになります。

- `( -1, 0)` : 左に小さく傾ける
- `(-10, 0)` : 左に大きく傾ける
- `(  5, 5)` : 右斜め前に傾ける

### ボタン

![コントローラーのボタン部に焦点](/images/books/nunchuk-mouse/nunchuck_data-02.png =320x)

C ボタンと Z ボタンは、それぞれオン・オフの 2 値で表現することができます。プログラミングに関して言えば、オンオフは `true`, `false` または数値の `1`, `0` で表現することが多いです。[^1]

[^1]: 数値の `1`, `0` とブーリアン値（`true`, `false`）の対応関係は、言語により違います。Arduino では、`false` が `0`、`true` が `1`（≒ `0` 以外）となっています。

仮に両ボタンを `(c, z)` の関係で数値表現した場合、例えば下記のようになります。

- `(1, 1)` : 両ボタンとも解放（押していない）状態
- `(0, 0)` : 両ボタンとも押下状態
- `(1, 0)` : Z ボタンのみ押下した状態

:::message

リポジトリのコードではわかりやすいように `1` を押下（`true`）、`0` を解放（`false`）とするように、**実際の情報をあえて反転しています**。

これはプログラミングにあまり触れていない人にとって、押下した状態を「オン」と表現（`1`, `true`）した方が直感的だからです。

:::

### 加速度センサ

![コントローラーの加速度に焦点](/images/books/nunchuk-mouse/nunchuck_data-03.png =320x)

最後に加速度情報です。これはスティックやボタンのように目に見えるものではないため、少し複雑な話になります。

ゲームによっては、ヌンチャクを振ることでアクション（剣撃を出したり、ラケットを振ったりなど）を起こすことができます。これはヌンチャクに加速度センサーが搭載されており、**自身にかかっている運動量を計測することができる**ためです。

この加速度センサーは `(x, y, z)` の 3 軸情報で表現されます。例えば下図のように傾けてみることにします。

![コントローラーを6方向に傾けた図](/images/books/nunchuk-mouse/axis-01.png)

原点が `(0, 0, 0)`、傾けた際は静止状態（≒運動エネルギーをかけない）とした場合、例えば下記のようになります。

|`x`|`y`|`z`|向き|備考|
|:---:|:---:|:---:|:---|:---|
|`0`|`0`|`100`|Upright(Face Up)|通常時の持ち方|
|`-100`|`0`|`0`|Left Roll(Tilt Left)|左方向に傾ける|
|`0`|`100`|`0`|Pitch Down(Lean Foward)|前方向に傾ける|
|`0`|`0`|`-100`|Inverted(Face Down)|表裏反転（裏面が天井方向を向くように持つ）|

:::message

ヌンチャクは ±3G まで計測することができるそうなので、これに加速エネルギーをかけると上記の例（`±100` の範囲）以上に変動します。

例えばヌンチャクを前に傾ける（Pitch Down）状態を `(0, 100, 0)` と表現していますが、勢いをつけ振るように傾けると `(0, 200, 0)` のような値になります。その後 静止状態で保持し続けると `(0, 100, 0)` の状態になるまで低減していきます。

:::

## I2C通信

**I2C**[^2]は、集積回路（*IC*）間で通信することを目的に、フィリップス社が開発したデジタル通信方式のことです。

[^2]: I2C（Inter-Integrated Circuit）：データ通信の 1 種で、信号線 2 本を用いたシリアル通信を指す。安価でありつつ、ある程度の通信速度と精度を持ち、さらにバス通信も可能と、コストパフォーマンスに優れている。

![コントローラー端子に直接ジャンプワイヤを配線](/images/books/nunchuk-mouse/cabling-02.png =240x)

上図は、コントローラーの端子にワイヤを接続した状態です。信号線としての 2 本（`SDA`[^3], `SCL`[^4]）と電源としての 2 本（`3,3V`, `GND`）の計 4 本で I2C による通信を行っていることがわかります。

[^3]: SDA（Serial Data）：データ本体をやり取りするための信号線
[^4]: SCL（Serial Clock）：一定周期で切り替わるクロック線。ここでのタイミングとSDAを組み合わせることで、`0`, `1` のデータに変換される

I2Cは仕様を調べてみると、少々複雑な通信手順を踏んでいることがわかります。Arduino では それを簡略化するために `Wire` ライブラリというものが用意されています。

### `Wire` ライブラリ

実際の I2C 通信では、「通信開始」「アドレス指定」「通信方向の指定」「データ通信」「受信完了確認」「通信停止」といった流れがあります。

Arduino では `Wire` ライブラリが用意されており、これを使えば I2C の仕様を知らなくてもデータをやり取りすることができます。

本段落では、リポジトリ内で扱うライブラリの機能について簡単に解説します。詳細については下記サイトを参照してください。

https://docs.arduino.cc/language-reference/en/functions/communication/wire/

#### `Wire.begin()`

Wire ライブラリを初期化し、機能を使えるようにします。

:::message

`Wire.end()` で終了させることもできますが、通信を終了させる意味がないためリポジトリ内では使用していません。

また、引数として `int adress` を指定することもできます。指定すると Arduino 側がスレーブになる場合の制御用アドレスとなります。今回 Arduino はマスターとなるので、引数は不要です。

:::

#### 送信関係

##### `Wire.beginTransmission(アドレス)`

指定したアドレスに対し、送信処理を開始します。

:::details 個人メモ

今回扱うコントローラーは、アドレス `0x52` で固定です。

もし I2C デバイスのアドレスがわからない場合は、スキャンすることで調べられる場合があります。  
（※ 全てのデバイスに対応しているわけではないですが、例えば "*i2c_scanner*" などがあります）

:::

##### `Wire.write(データ)`

送信したいデータをキューに入れます。I2C デバイスにデータを書き込む際に使用します。

所定の**レジスタ**に値を書き込みたい場合は、処理を２つに分け それぞれで `Wire.write()` を行います。

1. レジスタのアドレス（≠ デバイスのアドレス）
2. データ

:::message

**レジスタ**とは、I2C デバイスに搭載されている データを格納するための保存領域を指します。マスター・スレーブ間でのデータやり取りは、基本的には ここを通じて行われます。

例えば、センサーから取得した情報はこのレジスタに蓄えられます。そしてマスターがデータを取得したい場合は、該当するレジスタにアクセスし、内容を参照することになります。

先程の例はスレーブ側からマスターにデータを送る内容でしたが、逆にマスターがレジスタに書き込み、スレーブである I2C デバイスが読み取り何かしらを実行するといったことも可能です。

レジスタはメモリのように複数の保存領域で構成され、アドレスとデータで 1 つのセットとなります。下表は、そのイメージです。

|アドレス|データ|
|---|---|
|`0x00`|`0x11`|
|`0x01`|`0x28`|
|`0x02`|`0x58`|
|`0x03`|`0x09`|
|・・・|・・・|

:::

:::message

`Wire.write()` の処理は、通信状態中でなければなりません。

言い換えれば、`Wire.beginTransmission()` から `Wire.endTransmission()` までの間でのみ記述することができます。

:::

##### `Wire.endTransmission()`

`Wire.beginTransmission()` で開始した送信処理を終了します。

返り値があり、それを使って通信結果を知ることができます。

#### 受信関係

##### `Wire.requestFrom(アドレス, バイト数)`

指定したアドレスに対し、指定したバイト数のデータを要求します。

##### `Wire.available()`

`Wire.read()` で読み取れるバイト数を返します。

これを条件分岐に使い、「読み取れるデータが残っている間は、`Wire.read()` でデータを読み取る処理を繰り返す」といったことができます。[^5]

[^5]: Arduino の `false` が `0`、`true` がそれ以外であることを利用し、`while (Wire.avaiable()){...}` で「データが残っている間は受信用の処理を続ける」といった手法がよく使われます。

##### `Wire.read()`

送られてきた 1 バイト分のデータを取得します。

## まとめ

本項では、コントローラー（Wii ヌンチャク）の物理的な機能と通信方法について説明しました。

コントローラーではスティック、ボタン、加速度といったデータを扱い、それらは I2C 通信でやり取りすることができます。Arduino では `Wire` ライブラリを使うことで、I2C デバイスとのデータやり取りを容易に行うことが可能です。

次項では、操作を反映する先となるマウスについて見ていきます。
