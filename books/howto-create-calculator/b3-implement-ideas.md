---
title: "設計③：機能と情報を実装する手法について"
---

## 本項について

ここからは、上記で決めた情報と機能をプログラミングでどう実装していくかを考えていきます。重要となるのは、下記の２つです。

1. 電卓が保持する「式」はどのような形式なのか？
2. バックスペース処理用の、式や状態の履歴情報をどのように管理するか？

### 式をどのような形式にするか

まず考えるのは 電卓が保持する**式**を、どのような形式にするかです。本項では単純な**1つの文字列**形式を採用しています。

![式を変数にする際、「左辺（数値）」「演算子（文字列）」「右辺（数値）」の３つに分割するか、「式（文字列）」で１つにするか、どちらがいいか悩んでいるイメージ](/images/books/howto-create-calculator/variable-expression.png)
*式情報を分けて管理すべきか、まとめて管理すべきか？*

#### 3つの適切なデータ型で管理する

式を見た時、「左辺」「演算子」「右辺」に分割することができます。なので、直感的に「**両辺は数値、演算子は文字列にして、計3つの変数で管理**すれば」と考えるかもしれません。

一見すると、入力に対して適切なデータ型なのだから、良さそうにも見えます。計算も、演算子の内容に合わせて両辺の変数をそのまま使うこともできます。両辺の「数値」は 小数にも負数にもなり得るので、負数に対応できる小数型であれば、問題はなさそうです。

ただ、**バックスペース処理**が問題です。電卓上での「最後の文字を消す」という処理ですが、コードに起こすと どうなるでしょう？

小数、整数、負数それぞれで消し方は変わるかもしれません。また、**右辺→演算子**や**演算子→左辺**へと状態遷移する場合の特別な処理（処理対象となる変数の切り替え）も必要になりそうです。

想定する機能に対し、（複雑化させる）それだけのコストを負担すべきか、後者に挙げる方法と比較衡量する必要があります。

:::message

今回はこちらの方法を採用していませんが、これは *こちらの方法が劣っていること* を意味するものではありません。

今回の電卓は「四則演算ができる簡易的なもの」であり、それを実装する上でこの方法を取るメリットがほぼありませんでした。ですが例えば「関数電卓」や「専用電卓」など**複雑な機能を実装する場合に、この結論は変わる可能性があります**。

:::

#### 1つの文字列型として管理する

こちらの手法は `1+1`, `0.1234*-20` のように、**式をそのまま1つの文字列として管理する**というやり方です。計算処理までは文字列として管理し、必要になったタイミングで「左辺」「演算子」「右辺」に分割して処理を行うわけです。これには**管理が非常に単純という他、バックスペース処理の実装が簡単**というメリットがあります。

プログラミング言語は それぞれに特有な機能や性質を持っていますが、共通している部分も多いです。そして文字列に関する操作、例えば*文字列から最後の文字を消す*（≒最後の文字を除いた文字列を再取得する）という処理は、だいたいの言語で実装は容易でしょう。例えば JavaScript なら、下記のようになります。

```javascript:JavaScriptで文字列末尾を消去する例
let expr = '100+200';

// 両方とも、部分文字列を再取得する方法
const result1 = expr.substring(0, expr.length -1);  // -> '100+20'
const result2 = expr.slice(0, -1);                  // -> '100+20'
```

他にも、例えば Python なら下記のようになります。

```python:Pythonで文字列末尾を消去する例
expr = "100+200"

# スライス
result3 = expr[:-1]

# 文字列を文字単位でループ（末尾を除いた回数分）
result4 = ''.join([i for i in expr[:-1]])
```

このように実装が単純で、更に「右辺→演算子」や「演算子→左辺」へと状態遷移する場合の特別な処理も必要ありません。それぞれが独立してるわけでなく1つの文字列として管理されているので、考慮する必要がないからです。演算子にかかろうが、状態が遷移しようが、処理は上記のコードで問題ありません。

では、計算処理時に**演算子の位置から、左辺・演算子・右辺に分割する**のはどうすればいいでしょうか？ もっと言えば、式としてのバリエーション `1-1`, `-1-1`, `1--1`（≒ `1 - (-1)`）, `-1--1`（≒ `(-1) - (-1)`）, `0.1234-1` から、負数の `-` と区別した上で、どのようにして**演算子の位置を割り出す**ことができるでしょうか？

今回実装する電卓（四則演算のみの簡易なもの）なら、**2文字目以降で最初にヒットした演算子記号**が全てのバリエーションで条件を満たします。1文字目は負数記号がありえるので駄目ですが、2文字目以降なら必ず演算子記号になります。右辺の負数記号が演算子より前に来ることはありえないためです。なので、演算子位置を割り出すことは問題なくできるので、計算処理の課題はクリアできました。

このような理由から、本項ではこちらの手法を採用しています。ただし式と違って**状態情報は単純に前後するわけではない**ので、そこは別途考えていく必要があります。

### 式や状態の履歴をどう管理するか

式を1つの文字列で管理することを決めたので、次は状態を含め**履歴をどのように管理するか**を考えていきます。本項では**複雑な履歴データによる管理でなく、状態リセットから式を再計算する手法**を採用しています。

下図は「電卓に実装する機能」で話した、バックスペース機能についてです。

![先述したバックスペース機能。人が電卓に「１字戻して」と命令している状況](/images/books/howto-create-calculator/action-backspace-01.png)
*式を`1+1`->`1+`に、状態を「右辺」から「演算子」へ遷移*

上図の状態は「右辺」から「演算子」に遷移していますが、必ずしもこうなるとは限りません。式 `1+100` ならバックスペース処理で `1+10` になるので状態は変わらず「右辺」です。式 `1+-1` ならバックスペース処理で `1+-` になるので、状態としては「負数入力２」になります。このように、**状態は式と違い単純に前後するわけではありません**。

なので何かしらの方法で、状態の移り変わりを管理しなければなりません。

#### 履歴データによる管理

まず考えられる手法としては、電卓に**履歴データを保持させる**というものです。

![１字戻す方法として、電卓が履歴データを持っているイメージ図。電卓は「履歴0 : 式 空欄、状態 初期状態」から「履歴3 : 式 1+1、状態 右辺」と一連の履歴情報を持っており、履歴３を取り消し履歴２を現行にすることで処理内容を実現させている](/images/books/howto-create-calculator/action-backspace-02.png)

上図の方法は、実装できればかなり便利そうです。ですが**どこまで履歴に含めるのか、という問題**がありそうです。下記の状況を考えてみましょう。

- リセットで初期状態に戻した場合、履歴に含めるか？
- 計算結果を表示した際にも、履歴に含めるのか？

「リセット後にバックスペースを使うとリセット前に戻る」「計算式に `=` で計算結果を表示した後バックスペースを使うと計算式に戻る」というのは、直感的な操作に反しています。なので、こうしたケースではバックスペースは機能しないようしなければなりません。となると、各状態に応じて履歴に含めるか含めないかの処理が必要になりそうです。

このため、複雑になりそうな この手法は、できれば最後の手段にしておきたいと考えます。

#### 状態リセットからの再計算

次に、別の手法を考えてみます。こちらは「1度全消去した上で、**1字消した式をもう一度１から入れ直す**」というものです。

![１字戻す方法として、もう一度計算をやり直すイメージ図。式 1+1 から１字抜いた式 1+ を、リセットした初期状態から１つずつ入力し直して、処理内容を実現している](/images/books/howto-create-calculator/action-backspace-03.png)

一見すると「再計算するのは、エラーが起きるケースもあり得るのでは？」と考えるかもしれません。ですが再入力処理は、実際に OK だった式を入れ直す行為なので、入力エラー等は発生しません。**１から計算し直しという処理の無駄はありますが、実装は履歴データに比べると圧倒的に単純です**。

以上より本項では、バックスペース機能はこちらの手法を採用しています。

:::message

ただしこの手法も万全というわけでなく、[一部の想定外の操作](./c4-method-reset-and-back#バックスペース処理のハック的な操作)を許容する課題を抱えています。また[式データの管理にあった注記](#式をどのような形式にするか)同様、実装する機能とコストの比較衡量の結果であるため、内容によっては この結論は変わる場合がありえます。

:::
